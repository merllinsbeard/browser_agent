## Codebase Patterns
- Use `uv run` for all Python commands (e.g., `uv run mypy src/`, `uv run pytest`)
- Project uses strict mypy settings (disallow_untyped_defs = true) - all functions must be typed
- pyproject.toml uses hatchling as build backend
- Use dependency-groups for dev dependencies (uv >=0.5.0)
- src/ layout: src/browser_agent/ contains all package code
- Playwright's `launch_persistent_context()` returns BrowserContext, not Browser - browser closes when context closes
- Use `str(path)` when passing pathlib.Path to Playwright APIs (they expect str, not Path)
- Use frozen dataclasses for immutable models (Action, PageSnapshot, ActionResult, InteractiveElement)
- Action inherits from both str and Enum for JSON serialization compatibility
- Element registry uses snapshot versioning to prevent stale element references
- Element refs follow pattern "elem-{index}" for predictable identification
- Some Playwright methods don't accept timeout (e.g., keyboard.press()) - check API docs
- For string parameters with fixed options, use Literal type for type safety (e.g., navigate.wait_until)
- Use `# type: ignore[import-untyped]` for libraries without type stubs (e.g., PyYAML)

# Ralph Progress Log
Started: Mon Jan 26 22:00:52 MSK 2026
---

## Jan 26, 2026 - US-001
- Created src/browser_agent directory with subdirectories: agents/, tools/, core/, models/, security/
- Created scripts/run.py and scripts/eval.py entry points
- Created tests/ directory
- Created pyproject.toml with uv, dependencies: playwright, openai-agents, pydantic, rich, pytest
- Set up basic CLI entry point at src/browser_agent/cli.py
- Typecheck passes with mypy

**Learnings for future iterations:**
- The pyproject.toml [project] section should NOT include `readme = "README.md"` if README.md doesn't exist - this causes build failures
- Use [dependency-groups] instead of deprecated [tool.uv.dev-dependencies] for uv >=0.5.0
- Run `uv run mypy src/` to verify type checking - it will auto-install dependencies and build the package

---

## Jan 26, 2026 - US-002
- Created src/browser_agent/core/browser.py with launch_persistent_context()
  - Takes Playwright instance and user_data_dir for session persistence
  - headless parameter defaults to False for visible (headful) browser
  - Returns BrowserContext (not Browser) - browser auto-closes when context closes
  - Includes detailed docstring with usage example and warnings
- Updated src/browser_agent/cli.py with argparse configuration:
  - --session-dir argument with default to ~/.browser-agent/session
  - --headless flag to optionally run in headless mode
  - Added test browser launch with Ctrl+C handling for graceful shutdown
- Typecheck passes (mypy strict mode)

**Learnings for future iterations:**
- Playwright's `launch_persistent_context()` returns BrowserContext directly, not (Browser, Context) tuple
- The browser is automatically closed when the context is closed - no need to track browser separately
- Chrome policies prevent automating the main user profile - always use a dedicated directory
- Use `str(path)` when passing pathlib.Path to Playwright APIs

---

## Jan 26, 2026 - US-003
- Created src/browser_agent/models/action.py:
  - Action enum (str, Enum) with CLICK, TYPE, PRESS, SCROLL, NAVIGATE, WAIT, EXTRACT, DONE
- Created src/browser_agent/models/element.py:
  - BoundingBox dataclass (x, y, width, height)
  - InteractiveElement dataclass with ref, role, name, aria_label, placeholder, value_preview, bbox
- Created src/browser_agent/models/snapshot.py:
  - PageSnapshot dataclass with url, title, interactive_elements, visible_text_excerpt, screenshot_path, notes, version
  - with_version() helper for incrementing snapshot version
- Created src/browser_agent/models/result.py:
  - ActionResult dataclass with success, message, new_snapshot, error
  - Static helpers: success_result() and failure_result()
- Typecheck passes (mypy strict mode)

**Learnings for future iterations:**
- Use frozen dataclasses for immutable models (prevents accidental modification)
- Action inherits from both str and Enum for JSON serialization and string comparison
- field(default_factory=list) for mutable default arguments in dataclasses

---

## Jan 26, 2026 - US-004
- Created src/browser_agent/core/registry.py:
  - StaleElementError: Custom exception with helpful error message
  - RegistryEntry: Stores element, snapshot_version, selector
  - ObservationResult: Result of page observation with elements and version
  - ElementRegistry class:
    - Assigns unique ref IDs (elem-0, elem-1, etc.)
    - Tracks snapshot version for validation
    - register_elements(): Register batch of elements with selectors
    - get_locator(): Returns Playwright Locator for element ref
    - get_element(): Returns InteractiveElement for element ref
    - increment_version(): Clears stale entries, increments version
    - clear(): Reset registry to initial state
- Stale element detection: Raises StaleElementError when using old element ref
- Dynamic selector mapping: Ref IDs map to Playwright locators at runtime
- Typecheck passes (mypy strict mode)

**Learnings for future iterations:**
- Element registry uses snapshot versioning to prevent acting on stale elements
- Element refs follow pattern "elem-{index}" for predictable identification
- Custom exceptions with detailed context help debugging (StaleElementError)

---

## Jan 26, 2026 - US-005
- Created src/browser_agent/tools/actions/ directory structure
- Created src/browser_agent/tools/actions/__init__.py
- Created src/browser_agent/tools/actions/click.py:
  - click() function with typed arguments (page: Page, registry, element_id, timeout)
  - Resolves element ID to Playwright Locator via ElementRegistry.get_locator()
  - Returns ActionResult.success_result() on successful click
  - Handles StaleElementError, PlaywrightTimeoutError, and generic exceptions
  - Configurable timeout (default 30000ms)
- Typecheck passes (mypy strict mode)

**Learnings for future iterations:**
- Action tools should follow pattern: resolve element via registry, perform action, return ActionResult
- Use PlaywrightTimeoutError alias to avoid confusion with built-in TimeoutError
- Action tools should handle all exceptions and return failure_result with error details

---

## Jan 26, 2026 - US-006 through US-012
Batch created all remaining action tools following established pattern:

- src/browser_agent/tools/actions/type.py (US-006):
  - type_() function for typing text into input elements by ref ID
  - Uses locator.fill() for text entry
  - Handles StaleElementError and PlaywrightTimeoutError

- src/browser_agent/tools/actions/press.py (US-007):
  - press() function for keyboard key presses
  - Supports standard keys and combinations (e.g., Control+A)
  - Note: page.keyboard.press() doesn't accept timeout parameter

- src/browser_agent/tools/actions/scroll.py (US-008):
  - scroll() function for page scrolling with dx, dy parameters
  - Uses JavaScript window.scrollBy() for scrolling
  - Reports scroll direction and distance in result message

- src/browser_agent/tools/actions/navigate.py (US-009):
  - navigate() function for URL navigation
  - wait_until parameter with Literal type ("load", "domcontentloaded", "networkidle", "commit")
  - Returns HTTP status in success message

- src/browser_agent/tools/actions/wait.py (US-010):
  - wait() function for waiting a specified timeout (ms)
  - Uses page.wait_for_timeout()

- src/browser_agent/tools/actions/extract.py (US-011):
  - extract() function for data extraction from page
  - Handles common targets: title, url, text, links, inputs
  - Generic fallback returns page content (first 2000 chars)

- src/browser_agent/tools/actions/done.py (US-012):
  - done() function for signaling task completion
  - Returns ActionResult with completion summary

- Updated __init__.py to export all action tools

Typecheck passes (mypy strict mode).

**Learnings for future iterations:**
- Some Playwright methods don't accept timeout (e.g., keyboard.press()) - check API docs
- For string parameters with fixed options, use Literal type for type safety
- Function name with trailing underscore (type_) to avoid shadowing built-in type

---

## Jan 26, 2026 - US-013 and US-014

- src/browser_agent/tools/observe.py (US-013):
  - browser_observe() function with typed arguments (page, registry, max_elements, max_text_length, screenshot_path)
  - Uses Playwright page.locator("body").aria_snapshot() for compact page representation
  - Parses YAML and extracts interactive elements by role priority (buttons, links, inputs first)
  - Limits to max_elements (default 60) of most important elements
  - Truncates visible text to max_text_length (default 3000) chars
  - Registers elements with ElementRegistry for ID-based actions
  - Returns PageSnapshot with url, title, interactive_elements, visible_text_excerpt, notes, version

- src/browser_agent/tools/screenshot.py (US-014):
  - capture_screenshot() function with typed arguments (page, output_path, full_page)
  - Auto-generates timestamped filename (screenshot-{timestamp}.png) if output_path not provided
  - Supports full_page parameter for viewport vs full-page capture
  - Creates parent directories automatically
  - Returns Path to saved screenshot

- Updated tools/__init__.py to export browser_observe and capture_screenshot

Typecheck passes (mypy strict mode).

**Learnings for future iterations:**
- Use `# type: ignore[import-untyped]` for libraries without type stubs (e.g., PyYAML)
- Playwright's aria_snapshot() returns YAML that needs parsing
- Element role priority system helps filter most important elements for LLM context

---

## Jan 26, 2026 - US-015 to US-018

- src/browser_agent/core/llm.py (US-015):
  - get_openrouter_client(): Returns OpenAI client configured for OpenRouter API
  - OPENROUTER_API_KEY environment variable for authentication
  - DEFAULT_MODEL: anthropic/claude-3.5-sonnet
  - call_llm(): Function for LLM calls with temperature and max_tokens parameters
  - Uses type: ignore[arg-type] for OpenAI SDK complex message types

- src/browser_agent/agents/planner.py (US-016):
  - PlannerAgent class for creating execution plans from user tasks
  - create_plan(): Breaks down natural language task into step-by-step plan
  - Maintains URL history for backtracking
  - Uses LLM to generate numbered list of action steps
  - Returns structured plan as list of step descriptions

- src/browser_agent/agents/navigator.py (US-017):
  - NavigatorAgent class for executing browser actions according to plan
  - execute_step(): Executes single step from the plan
  - Observes page before each action via browser_observe()
  - Parses step description to determine action type (NAVIGATE, CLICK, TYPE, PRESS, SCROLL, WAIT, EXTRACT, DONE)
  - Calls corresponding action tools with extracted parameters
  - Returns ActionResult with success/failure status
  - Tracks actions completed count

- src/browser_agent/agents/safety.py (US-018):
  - SafetyAgent class for confirming destructive actions
  - CODE-LEVEL keyword matching for destructive patterns (delete, remove, spam, submit, payment, checkout, etc.)
  - check_action_safe(): Returns "allow", "block", or "skip" based on pattern matching
  - Destructive actions trigger rich-formatted confirmation prompt via rich console
  - User responds with yes/no via console input
  - Tracks statistics (blocked/allowed counts)
  - Security enforced at code level, not LLM level

- Updated agents/__init__.py to export all agent classes

Typecheck passes (mypy strict mode).

**Learnings for future iterations:**
- Sub-agents follow pattern: Planner creates plan, Navigator executes actions, Safety confirms destructive actions
- Use assert isinstance(result, ExpectedType) as type guard when mypy can't infer narrow types
- Rich console formatting makes confirmation prompts clear and user-friendly
- Pattern matching with predefined keywords is more reliable than LLM-based safety checks

---

## Jan 26, 2026 - US-019

- src/browser_agent/core/recovery.py (US-019):
  - detect_and_handle_overlays(): Main function for detecting and dismissing modal overlays
  - Detects dialogs via role='dialog' and aria-modal attributes in interactive elements
  - Three dismissal strategies attempted in order:
    1. Close button (Ã—, x, close) with aria-label pattern matching
    2. Cancel/Close/No/Dismiss buttons via text search
    3. Escape key press as fallback
  - Returns tuple: (overlays_found, dismissal_result_message)
  - needs_reobservation(): Helper to check if failed action requires page re-observation
  - Pattern matching for error types: detached, timeout, not found, stale, unexpected

- Updated src/browser_agent/core/__init__.py to export detect_and_handle_overlays and needs_reobservation

Typecheck passes (mypy strict mode).

**Learnings for future iterations:**
- Overlay dismissal should try multiple strategies in order: targeted close button first, then generic cancel buttons, then keyboard shortcuts
- Error pattern matching helps determine when page re-observation is needed vs other recovery strategies

---

## Jan 26, 2026 - US-020

- src/browser_agent/core/recovery.py (US-020):
  - RetryAttempt class: Represents a single retry attempt with strategy and description
  - RetryResult class: Result of retry operation with success, final_result, attempts_made, should_ask_user
  - retry_with_backoff(): Main retry function with exponential backoff (1s, 2s, 4s for max 3 attempts)
  - Three different retry strategies (never same action twice):
    1. Re-observe and check for overlays (signals caller to re-observe)
    2. Wait for network/selector stability with page.wait_for_load_state("networkidle")
    3. Extended wait with overlay check via browser_observe() and detect_and_handle_overlays()
  - Returns RetryResult with should_ask_user=True after 3 consecutive failures

- Updated src/browser_agent/core/__init__.py to export RetryAttempt, RetryResult, retry_with_backoff

Typecheck passes (mypy strict mode).

**Learnings for future iterations:**
- Use Callable[[], ActionResult] from typing for function parameter types
- Exponential backoff: backoff = initial * (2 ** attempt_num) gives 1s, 2s, 4s sequence
- Different recovery strategies prevent repeating the exact same action that just failed
- should_ask_user flag signals when automatic recovery is exhausted

---

## Jan 26, 2026 - US-021

- src/browser_agent/core/recovery.py (US-021):
  - StuckDetector class: Tracks consecutive actions without progress
  - record_action(): Records action results with URL and snapshot version tracking
  - _is_progress(): Determines if action made meaningful progress (new snapshot, new URL, DONE action)
  - is_stuck(): Returns True when consecutive_failures >= 5 or actions_without_progress >= 10
  - get_stuck_message(): Returns human-readable message with failure counts, URL history, login/2FA hints
  - reset(): Clears stuck state for fresh start
  - detect_stuck(): Simple functional API for stuck detection with (is_stuck, message) tuple return

- Updated src/browser_agent/core/__init__.py to export StuckDetector and detect_stuck

Typecheck passes (mypy strict mode).

**Learnings for future iterations:**
- Progress detection: new snapshot version > old version, new URL not in recent history, DONE action
- Stuck threshold: 5 consecutive failures OR 10 actions without progress (more lenient for no-progress case)
- URL history tracking helps detect URL loops (same 3 URLs repeatedly)
- reset() method allows clearing stuck state after user intervention

---

## Jan 26, 2026 - US-022

- src/browser_agent/core/context.py (US-022):
  - ContextTracker class: Tracks and manages context to prevent token bloat
  - update_snapshot(): Updates current snapshot, returns previous (old snapshot discarded)
  - get_current_snapshot(): Returns most recent PageSnapshot (or None)
  - record_action(): Records action in history with type, success, message
  - get_action_history(): Returns full action history (most recent first)
  - get_recent_actions(): Returns last N actions (default 10)
  - record_llm_call(): Records LLM call with optional token count
  - get_llm_call_count(): Returns total LLM calls made
  - get_total_tokens_used(): Returns total estimated tokens used
  - get_context_summary(): Returns dict with context statistics
  - reset(): Clears all context state

- Single-snapshot retention: Only most recent snapshot kept, old ones discarded
- Action history limited to max 50 entries (configurable)
- LLM call and token tracking for budget monitoring

- Updated src/browser_agent/core/__init__.py to export ContextTracker

Typecheck passes (mypy strict mode).

**Learnings for future iterations:**
- Type annotation for dict with mixed types: dict[str, str | bool] with explicit variable annotation
- Single-snapshot retention prevents token bloat from accumulating old page states
- Action history with max length provides recent context without unlimited growth

---

## Jan 26, 2026 - US-023

- src/browser_agent/core/context.py (US-023):
  - Added compression_interval parameter to __init__ (default 10 steps)
  - Added _compressed_summary field to store compressed history
  - should_compress(): Returns True when action count >= compression_interval
  - compress_task_memory(): Compresses older steps into summary format:
    - Counts actions by type (CLICK, NAVIGATE, etc.)
    - Calculates success rate percentage
    - Keeps 5 most recent steps in detail
    - Includes current state (URL, task, page title)
    - Returns formatted summary string
  - get_compressed_summary(): Returns stored compressed summary
  - Updated reset() to clear _compressed_summary

- Summary format example:
  ```
  Completed 15 actions:
    Actions: 5 click(s), 3 navigate(s), 2 type(s), 5 wait(s)
    Success rate: 12/15 (80%)

  Current state:
    URL: https://example.com
    Task: Search for products
    Page: Product Search
  ```

Typecheck passes (mypy strict mode).

**Learnings for future iterations:**
- Use isinstance() type narrowing when accessing dict values with union types
- Task compression keeps recent 5 steps detailed while summarizing older ones
- Compression reduces token usage while preserving recent context
- Success rate calculation: (successful / (successful + failed)) * 100

---
