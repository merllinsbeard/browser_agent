# Ralph Progress Log
Started: Tue Jan 27 23:01:18 MSK 2026
---

## Codebase Patterns
- Playwright aria_snapshot() returns YAML string, not structured object. Use yaml.safe_load() then regex parsing on keys/items.
- ARIA node format: `role "name" [attr=val]` — regex `r'^(\w+)(?:\s+"(.*)")?(?:\s+\[(.+)\])?$'` parses all three parts.
- Cross-module import cleanup: when deleting a module, check __init__.py files AND all importing modules (grep for `from browser_agent.X import`).
- ElementRegistry.register_elements() takes only elements (no selectors). Groups by (role, name) for nth index.
- Playwright get_by_role() expects Literal type for role — use `cast(Any, role)` with mypy.
- Registry `get_locator()` returns sync `Locator`, but works with async `Page` at runtime (same method names). Use `locator: Any` to avoid mypy errors when awaiting async methods.
- `@function_tool` from `agents` SDK works inside factory closures — each decorated function captures page/registry via closure.
- For async tools that call sync Playwright registry methods, use `cast(Any, page)` for the page arg and `locator: Any` for the returned locator.
- Safety checks in `browser_click`/`browser_type`: get element FIRST via `registry.get_element()`, check `is_destructive_action(f'{role} {name}')`, confirm with user if destructive.
- `Runner.run(agent, input, max_turns=N)` from `agents` SDK is the main async entry point. Returns `RunResult` with `.final_output`. Catch `MaxTurnsExceeded` from `agents.exceptions`.
- Async Playwright: use `await async_playwright().start()` (returns pw), then `await pw.stop()` in finally. NOT a context manager.

---

## 2026-01-28 00:55 - US-003
- **What was implemented**: Verified ARIA snapshot parser (already fixed in commit 477286e)
- **Files changed**: No code changes needed — parser was already correct
- **Verification**: browser_observe() on example.com returns 1 element: `elem-0: [link] 'Learn more'`
- **Learnings for future iterations:**
  - Playwright's aria_snapshot() returns a YAML string with specific format: string items like `heading "Example Domain" [level=1]`, dict keys like `link "Learn more"`, and `/url` metadata keys to skip
  - The `text` role should be skipped (not interactive)
  - _ROLE_PRIORITY dict controls which ARIA roles are captured as interactive elements
  - example.com is a good minimal test target — has exactly 1 interactive element (a link)
---

## 2026-01-28 01:00 - US-004
- **What was implemented**: Element Registry with get_by_role locators
- **Files changed**:
  - `src/browser_agent/core/registry.py` — RegistryEntry/ObservationResult converted to Pydantic, register_elements() takes only elements (no selectors), get_locator() uses get_by_role
  - `src/browser_agent/tools/observe.py` — removed role_index_map/selectors CSS logic
- **Verification**: get_locator('elem-0') on example.com returns `internal:role=link[name="Learn more"i] >> nth=0`, click succeeds
- **Learnings for future iterations:**
  - Playwright's `get_by_role()` expects a Literal type for role, not plain str — use `cast(Any, role)` to satisfy mypy
  - When grouping elements by (role, name) for nth disambiguation, use a dict counter pattern: `counts[(role, name)] = counts.get((role, name), 0) + 1`
  - The nth index is 0-based in Playwright's `.nth()` method
---

## 2026-01-28 03:35 - US-005
- **What was implemented**: Async browser context — `launch_persistent_context_async()` function
- **Files changed**:
  - `src/browser_agent/core/browser.py` — added async function using `playwright.async_api`
  - `src/browser_agent/core/__init__.py` — added export for `launch_persistent_context_async`
- **Verification**: Async context launches, navigates to example.com, reads page title, closes cleanly
- **Learnings for future iterations:**
  - Playwright async API mirrors sync API exactly — `async_playwright().start()` returns `AsyncPlaywright`, types are `AsyncBrowserContext`, etc.
  - Import async types separately: `from playwright.async_api import BrowserContext as AsyncBrowserContext`
  - The async `launch_persistent_context()` returns a context with `ctx.pages` already populated (same as sync)
---

## 2026-01-28 03:40 - US-006
- **What was implemented**: OpenRouter async client for OpenAI Agents SDK
- **Files changed**:
  - `src/browser_agent/core/llm.py` — added `setup_openrouter_for_sdk()` function using `AsyncOpenAI` + `set_default_openai_client()`, added `DEFAULT_SDK_MODEL` constant
  - `src/browser_agent/core/__init__.py` — exported `setup_openrouter_for_sdk` and `DEFAULT_SDK_MODEL`
- **Verification**: `setup_openrouter_for_sdk()` configures SDK client without error. Import and mypy pass.
- **Learnings for future iterations:**
  - OpenAI Agents SDK uses `set_default_openai_client()` from `agents` package to configure the LLM backend — accepts an `AsyncOpenAI` instance
  - OpenRouter works with `AsyncOpenAI(base_url="https://openrouter.ai/api/v1", api_key=...)` — fully OpenAI-compatible async client
  - The agents SDK v0.7.0 is installed and provides `set_default_openai_client`
---

## 2026-01-28 03:50 - US-007
- **What was implemented**: Browser tools as `@function_tool` for OpenAI Agents SDK
- **Files changed**:
  - `src/browser_agent/tools/browser_tools.py` — new file with `create_browser_tools(page, registry)` factory returning 10 `@function_tool` async functions
  - `src/browser_agent/tools/__init__.py` — added `create_browser_tools` export
- **Tools implemented**: `browser_observe`, `browser_click`, `browser_type`, `browser_press`, `browser_scroll`, `browser_navigate`, `browser_wait`, `browser_extract`, `browser_done`, `ask_user`
- **Verification**: Import from both `browser_agent.tools.browser_tools` and `browser_agent.tools` succeeds. mypy clean.
- **Learnings for future iterations:**
  - The `@function_tool` decorator works inside factory closures — each tool captures `page` and `registry` via closure scope
  - `registry.get_locator()` returns sync `Locator` type, but at runtime returns async `Locator` when given async `Page`. Use `locator: Any` annotation to avoid mypy `func-returns-value` error on `await locator.click()`
  - `cast(Any, page)` bridges the sync/async type gap when passing async `Page` to `registry.get_locator()`
  - `asyncio.to_thread()` works for wrapping blocking `rich.Prompt.ask()` in async context
  - `browser_navigate()` must call `registry.increment_version()` after successful navigation to invalidate stale element refs
  - `_extract_interactive_elements()` from observe.py is pure Python (no Playwright calls) — safe to reuse in async tools
---

## 2026-01-28 03:55 - US-008
- **What was implemented**: Navigator Agent using OpenAI Agents SDK
- **Files changed**:
  - `src/browser_agent/agents/navigator.py` — deleted old NavigatorAgent class, created `create_navigator_agent(browser_tools)` factory returning SDK `Agent`
  - `src/browser_agent/agents/__init__.py` — added `create_navigator_agent` export
- **Verification**: `from browser_agent.agents import create_navigator_agent` succeeds. mypy clean (0 issues in 30 files).
- **Learnings for future iterations:**
  - SDK `Agent` constructor takes: `name`, `instructions` (str), `tools` (list[Tool]), `model` (str), plus optional `handoffs`, `model_settings`, etc.
  - The `Tool` type from `agents` is the base type for `@function_tool` decorated functions — use `list[Tool]` for type annotations
  - System prompt (instructions) is critical for ReAct behavior — must explicitly tell the agent to observe first, use element IDs, handle failures, and call browser_done() when complete
  - The Navigator agent doesn't need handoffs — it receives control from the Planner and uses tools to complete the task
---

## 2026-01-28 04:00 - US-009
- **What was implemented**: Planner Agent with SDK handoff to Navigator
- **Files changed**:
  - `src/browser_agent/agents/planner.py` — deleted old PlannerAgent class, created `create_planner_agent(navigator_agent)` factory returning SDK `Agent` with `handoffs=[navigator_agent]`
  - `src/browser_agent/agents/safety.py` — removed SafetyAgent class (safety moves to US-010 at tool level)
  - `src/browser_agent/agents/__init__.py` — removed PlannerAgent and SafetyAgent exports, now exports only `create_navigator_agent` and `create_planner_agent`
- **Verification**: `from browser_agent.agents import create_navigator_agent, create_planner_agent` succeeds. mypy clean (0 issues in 30 files).
- **Learnings for future iterations:**
  - SDK `Agent` constructor accepts `handoffs: list[Agent | Handoff]` for agent-to-agent delegation
  - The Planner agent has NO tools — it only plans and hands off. The Navigator has all the browser tools.
  - `handoffs=[navigator_agent]` makes the SDK automatically offer the handoff as an action the LLM can take
  - The Planner's system prompt must explicitly tell it to hand off after planning — otherwise the LLM may try to act without tools
  - `type: ignore[type-arg]` needed on `Agent` return type since it's generic (`Agent[TContext]`) but we don't use context
---

## 2026-01-28 04:10 - US-010
- **What was implemented**: Safety checks in browser tools — deterministic keyword-based destructive action detection and user confirmation
- **Files changed**:
  - `src/browser_agent/tools/safety.py` — new file with `is_destructive_action()` and `ask_user_confirmation()`
  - `src/browser_agent/tools/browser_tools.py` — integrated safety checks into `browser_click` and `browser_type`
- **Verification**: `is_destructive_action('delete account')` → True, `is_destructive_action('click search')` → False. mypy clean (0 issues in 31 files).
- **Learnings for future iterations:**
  - Safety checks are at the tool level (not agent/LLM level) — deterministic and unbypassable
  - `is_destructive_action()` splits on whitespace and checks against a frozenset of keywords — simple but effective
  - In `browser_click`/`browser_type`, get the element BEFORE acting (via `registry.get_element()`) to check safety — previously element was retrieved after the action
  - `ask_user_confirmation()` uses `rich.prompt.Confirm` wrapped in `asyncio.to_thread()` for async compatibility (same pattern as `ask_user` tool)
---

## 2026-01-28 04:20 - US-011
- **What was implemented**: Async run.py with Runner.run() — full rewrite from sync linear executor to async SDK ReAct loop
- **Files changed**:
  - `scripts/run.py` — complete rewrite: async def main() with asyncio.run(), async_playwright(), launch_persistent_context_async(), setup_openrouter_for_sdk(), create_browser_tools/agents, Runner.run(planner, task, max_turns=30), MaxTurnsExceeded handling, --clean-cache flag
  - `scripts/eval.py` — removed broken old imports (PlannerAgent, NavigatorAgent, SafetyAgent, ContextTracker, StuckDetector), replaced with placeholder for US-013
  - `src/browser_agent/core/context.py` — deleted (ContextTracker no longer needed, SDK manages context)
  - `src/browser_agent/core/__init__.py` — removed ContextTracker import and __all__ entry
  - `scripts/ralph/prd.json` — marked US-011 as passes: true
- **Verification**: `uv run python scripts/run.py --help` works (shows all args including --clean-cache). `uv run python -c "import browser_agent"` succeeds. mypy clean (0 issues in 33 files).
- **Learnings for future iterations:**
  - `Runner.run(agent, input, max_turns=N)` is the main SDK entry point — returns a `RunResult` with `.final_output` property
  - `MaxTurnsExceeded` is importable from `agents.exceptions` — raised when the agent exceeds the turn limit
  - async Playwright requires `await async_playwright().start()` (not a context manager) — must call `await pw.stop()` in finally block
  - `shutil.rmtree()` works for cleaning browser session cache directories
  - When deleting a module (context.py), also check scripts/ (eval.py used ContextTracker) — not just src/ __init__.py
---

## 2026-01-28 04:30 - US-012
- **What was implemented**: New test suite covering models, tools, and core modules (77 tests)
- **Files changed**:
  - `tests/__init__.py`, `tests/conftest.py` — test directory setup with shared fixtures
  - `tests/models/__init__.py`, `tests/models/test_element.py` — BoundingBox and InteractiveElement tests (6 tests)
  - `tests/models/test_snapshot.py` — PageSnapshot tests (7 tests)
  - `tests/models/test_result.py` — SuccessResult/FailureResult and factory function tests (12 tests)
  - `tests/tools/__init__.py`, `tests/tools/test_observe.py` — ARIA snapshot parser tests with real data (15 tests)
  - `tests/tools/test_safety.py` — is_destructive_action tests for all keywords and edge cases (18 tests)
  - `tests/core/__init__.py`, `tests/core/test_registry.py` — ElementRegistry tests with mock Page (14 tests)
  - `scripts/ralph/prd.json` — marked US-012 as passes: true
- **Verification**: `uv run pytest tests/ -v` — 77 passed in 0.04s. `uv run mypy src/ tests/` — 0 issues in 41 files.
- **Learnings for future iterations:**
  - `increment_version()` keeps entries but bumps `_current_version`, so entries become stale (raise `StaleElementError`) — they are NOT removed from `_entries`
  - Use `unittest.mock.MagicMock` to mock Playwright `Page` for `get_locator()` tests — mock `page.get_by_role().nth()` chain and `page.locator().nth()` chain
  - `yaml` import needs `# type: ignore[import-untyped]` for mypy — use at top of file, not inline in test methods
  - ARIA snapshot test data: use triple-quoted YAML strings matching real Playwright output format for realistic integration tests
  - Pydantic frozen models raise `ValidationError` (not `AttributeError`) on mutation attempts
---
