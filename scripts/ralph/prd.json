{
  "project": "Browser Agent",
  "branchName": "ralph/react-agent-sdk-rewrite",
  "description": "Rewrite browser agent from linear plan executor to true ReAct agent using OpenAI Agents SDK. Replace custom FOR-loop with SDK Runner.run() ReAct loop, fix broken ARIA parsing, replace CSS nth-of-type with get_by_role locators, implement Planner→Navigator handoff, convert to async Playwright, replace dataclasses with Pydantic.",
  "userStories": [
    {
      "id": "US-001",
      "title": "Remove old test suite and dead code",
      "description": "As a developer, I want to remove the old test suite and unused modules so subsequent stories can rewrite code without failing tests blocking commits.",
      "acceptanceCriteria": [
        "Delete entire tests/ directory",
        "Delete src/browser_agent/core/recovery.py (605 lines of dead code — never called from run.py)",
        "Delete src/browser_agent/tools/hybrid_observe.py (vision fallback not wired in)",
        "Delete src/browser_agent/security/ directory (empty)",
        "Update src/browser_agent/core/__init__.py: remove all recovery.py imports (RetryAttempt, RetryResult, StuckDetector, detect_and_handle_overlays, detect_stuck, needs_reobservation, retry_with_backoff) and their __all__ entries",
        "Update scripts/run.py: remove StuckDetector import and all stuck_detector usage (lines 16, 186, 263-271) — replace with pass or simple comment placeholder. Do NOT rewrite run.py fully (that's US-011)",
        "Run: uv run python -c \"import browser_agent\" — must succeed without ImportError",
        "Typecheck passes: uv run mypy src/"
      ],
      "priority": 1,
      "passes": true,
      "notes": "Completed: Deleted tests/, recovery.py, hybrid_observe.py, security/. Removed recovery imports from core/__init__.py. Removed StuckDetector from run.py. Also fixed tools/__init__.py hybrid_observe imports. Import and mypy pass."
    },
    {
      "id": "US-002",
      "title": "Pydantic models",
      "description": "As a developer, I want data models using Pydantic BaseModel so we get automatic validation, JSON serialization, and SDK-compatible structured output.",
      "acceptanceCriteria": [
        "Rewrite src/browser_agent/models/element.py: replace @dataclass(frozen=True) with Pydantic BaseModel + model_config = ConfigDict(frozen=True)",
        "BoundingBox: fields x: float, y: float, width: float, height: float with @field_validator for non-negative width/height",
        "InteractiveElement: fields ref: str, role: str, name: str = '' (name is NOT required — many ARIA elements have empty names), aria_label: str | None = None, placeholder: str | None = None, value_preview: str | None = None, bbox: BoundingBox | None = None",
        "Rewrite src/browser_agent/models/snapshot.py: PageSnapshot as Pydantic BaseModel with model_config = ConfigDict(frozen=True). Fields: url: str, title: str, interactive_elements: list[InteractiveElement] = [], visible_text_excerpt: str = '', screenshot_path: str | None = None, notes: list[str] = [], version: int = 0",
        "Rewrite src/browser_agent/models/result.py: SuccessResult and FailureResult as Pydantic BaseModel with model_config = ConfigDict(frozen=True). Keep success and error as properties. Keep success_result() and failure_result() factory functions. Remove updated_plan field from SuccessResult (SDK handles replanning natively)",
        "Update src/browser_agent/models/__init__.py to export all new models",
        "Run: uv run python -c \"from browser_agent.models import InteractiveElement, PageSnapshot, SuccessResult, FailureResult\" succeeds",
        "Typecheck passes: uv run mypy src/"
      ],
      "priority": 2,
      "passes": false,
      "notes": ""
    },
    {
      "id": "US-003",
      "title": "Fix ARIA snapshot parser",
      "description": "As the agent, I need working page observation so I can see interactive elements. The current parser is fundamentally broken — it expects dict nodes with a 'role' key, but Playwright's aria_snapshot() returns YAML where the role IS the dict key (e.g., button \"Submit\" is a key, not {\"role\": \"button\", \"name\": \"Submit\"}).",
      "acceptanceCriteria": [
        "Rewrite _traverse_aria_tree() in src/browser_agent/tools/observe.py to handle the actual Playwright ARIA snapshot format",
        "After yaml.safe_load(), the parsed structure contains: (a) string items in lists like 'heading \"Example Domain\" [level=1]', (b) dict items where keys are like 'link \"Learn more\"' or 'paragraph' and values are content or children",
        "Use regex r'^(\\w+)(?:\\s+\"(.*)\")?(?:\\s+\\[(.+)\\])?$' to parse role, name, attributes from both string items and dict keys",
        "_traverse_aria_tree recursively walks the parsed YAML: for each string item or dict key, extract (role, name) using the regex. If role is in _ROLE_PRIORITY, add to elements list. For dict values that are lists, recurse into children",
        "Skip keys starting with / (metadata like /url)",
        "Skip the text role (not interactive)",
        "Verified: browser_observe() on https://example.com returns at least 1 element (the 'More information...' link). Test with: uv run python -c \"from playwright.sync_api import sync_playwright; from browser_agent.tools.observe import browser_observe; from browser_agent.core.registry import ElementRegistry; p = sync_playwright().start(); b = p.chromium.launch(); page = b.new_page(); page.goto('https://example.com'); r = ElementRegistry(); s = browser_observe(page, r); print(f'Found {len(s.interactive_elements)} elements'); [print(f'  {e.ref}: [{e.role}] {e.name!r}') for e in s.interactive_elements]; b.close(); p.stop()\"",
        "Typecheck passes: uv run mypy src/"
      ],
      "priority": 3,
      "passes": false,
      "notes": ""
    },
    {
      "id": "US-004",
      "title": "Element Registry with get_by_role locators",
      "description": "As the agent, I need correct element locators. The current CSS [role=X]:nth-of-type(N) strategy is wrong — CSS nth-of-type works on HTML tag type, not role attribute, causing wrong elements to be clicked.",
      "acceptanceCriteria": [
        "Change RegistryEntry in src/browser_agent/core/registry.py to store role: str, name: str, nth: int instead of selector: str. Use Pydantic BaseModel (consistent with US-002)",
        "Change register_elements() to accept elements: list[InteractiveElement] only (no selectors param). Internally, group elements by (role, name) tuple to compute nth index for disambiguation",
        "Change get_locator() to build locator as: page.get_by_role(entry.role, name=entry.name).nth(entry.nth) if name is non-empty, or page.locator(f'[role={entry.role}]').nth(entry.nth) if name is empty",
        "Update ObservationResult to Pydantic BaseModel",
        "Update src/browser_agent/tools/observe.py: call registry.register_elements(elements) without selectors",
        "Remove the role_index_map / selectors logic from observe.py (lines 82-88)",
        "Verified: after browser_observe() on https://example.com, registry.get_locator(page, 'elem-0') returns a valid Locator that can be clicked without error",
        "Typecheck passes: uv run mypy src/"
      ],
      "priority": 4,
      "passes": false,
      "notes": ""
    },
    {
      "id": "US-005",
      "title": "Async browser context",
      "description": "As the system, I need async Playwright support because the OpenAI Agents SDK is fully async (Runner.run() is a coroutine), and all @function_tool functions must be async.",
      "acceptanceCriteria": [
        "Add launch_persistent_context_async() function to src/browser_agent/core/browser.py that uses playwright.async_api (async_playwright, async BrowserContext)",
        "Keep the existing sync launch_persistent_context() for backwards compatibility",
        "The async function has the same signature and behavior as the sync version",
        "Update src/browser_agent/core/__init__.py to also export launch_persistent_context_async",
        "Verified: uv run python -c \"import asyncio; from playwright.async_api import async_playwright; from browser_agent.core.browser import launch_persistent_context_async; asyncio.run(launch_persistent_context_async(async_playwright().start(), '/tmp/test-session'))\" — launches and closes without error",
        "Typecheck passes: uv run mypy src/"
      ],
      "priority": 5,
      "passes": false,
      "notes": ""
    },
    {
      "id": "US-006",
      "title": "OpenRouter async client for SDK",
      "description": "As the system, I need the OpenAI Agents SDK configured to use OpenRouter (OpenAI-compatible API) so agents can make LLM calls through Runner.run().",
      "acceptanceCriteria": [
        "Update src/browser_agent/core/llm.py: add function setup_openrouter_for_sdk() that calls set_default_openai_client() from agents package with an AsyncOpenAI client configured for OpenRouter (base_url='https://openrouter.ai/api/v1', api_key from OPENROUTER_API_KEY env var)",
        "Import: from openai import AsyncOpenAI and from agents import set_default_openai_client",
        "Keep existing sync call_llm() and get_openrouter_client() for now (will be removed when old code is fully replaced)",
        "Add DEFAULT_SDK_MODEL constant — set to 'google/gemini-2.5-flash-preview-05-20' (current best flash model on OpenRouter)",
        "Update src/browser_agent/core/__init__.py to export setup_openrouter_for_sdk and DEFAULT_SDK_MODEL",
        "Verified: uv run python -c \"from browser_agent.core.llm import setup_openrouter_for_sdk; setup_openrouter_for_sdk(); print('SDK client configured')\" succeeds (requires OPENROUTER_API_KEY set)",
        "Typecheck passes: uv run mypy src/"
      ],
      "priority": 6,
      "passes": false,
      "notes": ""
    },
    {
      "id": "US-007",
      "title": "Browser tools as @function_tool",
      "description": "As the SDK agent, I need browser actions exposed as @function_tool decorated async functions so the LLM can call them through the ReAct loop.",
      "acceptanceCriteria": [
        "Create src/browser_agent/tools/browser_tools.py with a factory function create_browser_tools(page, registry) -> list that returns a list of @function_tool decorated async functions",
        "Import from agents import function_tool",
        "The factory uses closures so each tool captures page (async Playwright Page) and registry (ElementRegistry)",
        "Tool: browser_observe() -> str — calls observe logic, returns formatted string: 'Page: {title}\\nURL: {url}\\n\\nInteractive Elements:\\n- elem-0: [{role}] \"{name}\"\\n...' with up to 60 elements and 3000 chars visible text",
        "Tool: browser_click(element_id: str) -> str — clicks element, returns success/failure. Catches StaleElementError and KeyError with helpful messages",
        "Tool: browser_type(element_id: str, text: str) -> str — types text into element, returns success/failure",
        "Tool: browser_press(key: str) -> str — presses keyboard key, returns success/failure",
        "Tool: browser_scroll(direction: str) -> str — scrolls page. direction is 'up' or 'down' (scroll by 500px). Returns success/failure",
        "Tool: browser_navigate(url: str) -> str — navigates to URL, returns success/failure. After successful navigate, increments registry version",
        "Tool: browser_wait(seconds: int) -> str — waits specified seconds (max 10), returns message",
        "Tool: browser_extract(target: str) -> str — extracts data from page (title, url, text, links, inputs), returns extracted data",
        "Tool: browser_done(summary: str) -> str — signals task completion, returns the summary (this becomes the agent's final output)",
        "Each tool has a clear docstring (the LLM sees these to decide which tool to call)",
        "All tools use await for async Playwright operations (e.g., await page.goto(url), await locator.click())",
        "Update src/browser_agent/tools/__init__.py to export create_browser_tools",
        "Verified: uv run python -c \"from browser_agent.tools.browser_tools import create_browser_tools; print('Factory imported')\" succeeds",
        "Typecheck passes: uv run mypy src/"
      ],
      "priority": 7,
      "passes": false,
      "notes": ""
    },
    {
      "id": "US-008",
      "title": "Navigator Agent using SDK",
      "description": "As the system, I need a Navigator agent built with the OpenAI Agents SDK that executes browser actions using the ReAct loop — the SDK automatically calls the LLM, which decides which tool to use, executes it, sees the result, and decides the next action.",
      "acceptanceCriteria": [
        "Rewrite src/browser_agent/agents/navigator.py: delete the old NavigatorAgent class entirely",
        "Create function create_navigator_agent(browser_tools: list) -> Agent that returns an SDK Agent instance",
        "Import from agents import Agent",
        "Agent configured with: name='Browser Navigator', instructions (detailed system prompt for ReAct behavior), tools=browser_tools, model=DEFAULT_SDK_MODEL",
        "System prompt explains: (1) you control a browser via tools, (2) ALWAYS call browser_observe() first, (3) use element IDs from observation, (4) re-observe on failure, (5) never repeat same failed action, (6) call browser_done() when complete, (7) explain if stuck after 3 failures",
        "Update src/browser_agent/agents/__init__.py to export create_navigator_agent",
        "Verified: uv run python -c \"from browser_agent.agents import create_navigator_agent; print('Navigator factory imported')\" succeeds",
        "Typecheck passes: uv run mypy src/"
      ],
      "priority": 8,
      "passes": false,
      "notes": ""
    },
    {
      "id": "US-009",
      "title": "Planner Agent with handoff to Navigator",
      "description": "As the system, I need a Planner agent that receives the user's task, creates a high-level plan, and hands off execution to the Navigator agent.",
      "acceptanceCriteria": [
        "Rewrite src/browser_agent/agents/planner.py: delete the old PlannerAgent class entirely",
        "Create function create_planner_agent(navigator_agent: Agent) -> Agent that returns an SDK Agent with a handoff to Navigator",
        "Import from agents import Agent",
        "Planner Agent configured with: name='Task Planner', instructions (system prompt for planning), handoffs=[navigator_agent], model=DEFAULT_SDK_MODEL",
        "System prompt explains: (1) receive browser automation task, (2) break into 3-10 high-level steps, (3) plan is general — NO specific element IDs, (4) hand off to Browser Navigator after planning",
        "Remove old SafetyAgent class from safety.py",
        "Update src/browser_agent/agents/__init__.py: remove SafetyAgent export, add create_planner_agent and create_navigator_agent",
        "Verified: uv run python -c \"from browser_agent.agents import create_navigator_agent, create_planner_agent; print('Both agent factories imported')\" succeeds",
        "Typecheck passes: uv run mypy src/"
      ],
      "priority": 9,
      "passes": false,
      "notes": ""
    },
    {
      "id": "US-010",
      "title": "Safety checks in browser tools",
      "description": "As a user, I want the agent to confirm before destructive actions. Safety is enforced at CODE level (keyword matching in the tool functions), not LLM level — the LLM cannot bypass it.",
      "acceptanceCriteria": [
        "Create src/browser_agent/tools/safety.py with function is_destructive_action(action_description: str) -> bool that checks for destructive keywords: delete, remove, spam, submit, payment, checkout, confirm, purchase, buy, order",
        "Create async function ask_user_confirmation(action_description: str) -> bool that prints action description to console (using rich) and prompts yes/no",
        "Integrate into browser_click and browser_type tools in browser_tools.py: before executing, check is_destructive_action(f'{element.role} {element.name}'). If destructive, call ask_user_confirmation(). If declined, return 'Action blocked by user'",
        "The safety check is synchronous keyword matching (no LLM call) — deterministic and unbypassable",
        "Delete src/browser_agent/agents/safety.py (old SafetyAgent class) if not already deleted in US-009",
        "Verified: uv run python -c \"from browser_agent.tools.safety import is_destructive_action; print(is_destructive_action('delete account')); print(is_destructive_action('click search'))\" prints True then False",
        "Typecheck passes: uv run mypy src/"
      ],
      "priority": 10,
      "passes": false,
      "notes": ""
    },
    {
      "id": "US-011",
      "title": "Async run.py with Runner.run()",
      "description": "As a user, I want the main CLI script to use the SDK's Runner.run() for true ReAct execution — the agent reasons on every step, adapts to failures, and completes tasks autonomously.",
      "acceptanceCriteria": [
        "Rewrite scripts/run.py as fully async: async def main() with asyncio.run(main()) at bottom",
        "Use async_playwright() context manager and launch_persistent_context_async() for browser setup",
        "Call setup_openrouter_for_sdk() to configure the SDK client",
        "Create browser tools: tools = create_browser_tools(page, registry)",
        "Create agents: navigator = create_navigator_agent(tools) then planner = create_planner_agent(navigator)",
        "Run: result = await Runner.run(planner, task, max_turns=30). Import from agents import Runner",
        "Keep existing CLI argument parsing (argparse): task, --session-dir, --headless, --auto-approve, --clean-cache",
        "Keep Rich console output for welcome banner, task display, and completion",
        "After Runner.run() completes, print result.final_output as the completion report",
        "Handle MaxTurnsExceeded exception — print warning that agent reached turn limit",
        "Keep browser open after completion (same Ctrl+C behavior as current)",
        "Delete src/browser_agent/core/context.py (ContextTracker) — SDK manages context natively",
        "Update src/browser_agent/core/__init__.py: remove ContextTracker export and import",
        "Clean up old imports from run.py: remove PlannerAgent, NavigatorAgent, SafetyAgent, StuckDetector, ContextTracker",
        "Verified: uv run python scripts/run.py --help shows usage without errors",
        "Typecheck passes: uv run mypy src/ scripts/"
      ],
      "priority": 11,
      "passes": false,
      "notes": ""
    },
    {
      "id": "US-012",
      "title": "New test suite",
      "description": "As a developer, I want tests for the new architecture to ensure reliability and catch regressions.",
      "acceptanceCriteria": [
        "Create tests/ directory with __init__.py and conftest.py",
        "tests/models/test_element.py: test InteractiveElement creation, optional name (empty string allowed), BoundingBox validation (negative width/height rejected), frozen immutability",
        "tests/models/test_snapshot.py: test PageSnapshot creation, default values, frozen immutability",
        "tests/models/test_result.py: test SuccessResult/FailureResult properties, factory functions",
        "tests/tools/test_observe.py: test _traverse_aria_tree with real ARIA snapshot samples. Include test data strings matching actual Playwright output format. Verify correct element count, role extraction, name extraction",
        "tests/tools/test_safety.py: test is_destructive_action with destructive and non-destructive inputs",
        "tests/core/test_registry.py: test ElementRegistry: register_elements, get_locator with mock Page, version tracking, StaleElementError on version mismatch",
        "All tests use pytest and pytest-asyncio where needed",
        "uv run pytest tests/ -v — all tests pass",
        "Typecheck passes: uv run mypy src/ tests/"
      ],
      "priority": 12,
      "passes": false,
      "notes": ""
    },
    {
      "id": "US-013",
      "title": "End-to-end demo verification",
      "description": "As a stakeholder, I want a working demo proving the ReAct architecture works — the agent observes, reasons, acts, and recovers from failures on a real browser task.",
      "acceptanceCriteria": [
        "Run: uv run python scripts/run.py \"go to example.com and tell me what the page title is\" — agent completes the task",
        "Verify the agent's execution log shows the ReAct loop: (1) Planner creates plan, (2) handoff to Navigator, (3) Navigator calls browser_observe, (4) Navigator calls browser_navigate, (5) Navigator calls browser_observe again, (6) Navigator calls browser_extract or browser_done",
        "The agent uses at least 2 different tools in sequence (not just navigate + done)",
        "If an action fails, the agent re-observes and tries a different approach (visible in execution log)",
        "Update scripts/demo.py to use the new async architecture (same pattern as run.py)",
        "Typecheck passes: uv run mypy src/ scripts/"
      ],
      "priority": 13,
      "passes": false,
      "notes": ""
    }
  ]
}
